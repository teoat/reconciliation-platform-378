Run a comprehensive and deep diagnosis of the entire codebase with automated remediation, historical tracking, and predictive analysis. Execute the following complete workflow:

PHASE 1: RUN ALL DIAGNOSTICS
1. Execute comprehensive diagnostic script: ./scripts/comprehensive-diagnostic.sh
2. Run SSOT validation: ./scripts/validate-ssot.sh
3. Run import validation: ./scripts/validate-imports.sh
4. Check backend compilation: cargo check --verbose (in backend/)
5. Check frontend type checking: npx tsc --noEmit (in frontend/)
6. Run linter checks: npm run lint and cargo clippy
7. Run security audits: npm audit and cargo audit
8. Run test coverage: ./scripts/test-coverage-audit-enhanced.sh
9. Run bundle analysis: ./scripts/analyze-bundle-size.sh
10. Use MCP diagnostic tools: run_diagnostic with scope='full'

PHASE 2: INVESTIGATE ALL FINDINGS
For each finding discovered:
- Perform root cause analysis (trace to source, identify contributing factors)
- Detect patterns (check if part of systemic issue, search for similar problems)
- Assess impact (severity: Critical/High/Medium/Low, business/user impact, fix complexity)
- Analyze dependencies (how issues relate, blocking relationships, fix order)
- Calculate risk scores for each module/component

PHASE 2.5: AUTOMATED REMEDIATION (V2)
- Identify auto-fixable issues (categorize: Safe/Review Required/Manual)
- Apply safe fixes automatically (formatting, imports, linting, simple type errors)
- Generate fix patches for review-required fixes (show diff, request approval)
- Validate fixes (compile, test, lint check)
- Generate fix report (list applied fixes, pending approvals, success rate)

PHASE 3: COMPREHENSIVE ANALYSIS
Generate complete analysis covering:
1. Executive Summary: Overall health score, critical issues count, top recommendations
2. Detailed Findings: For each category (Backend, Frontend, Security, Code Quality, Testing, Documentation):
   - Current state (scores, metrics, status)
   - Complete issues list with severity and risk scores
   - Root cause analysis
   - Impact assessment (business, technical, user)
   - Pattern detection (recurring issues, systemic problems)
   - Dependency mapping
3. Deep Investigation: For each critical/high issue:
   - Code examples showing the problem
   - Related issues found
   - Historical context (when/why introduced)
   - Contributing factors
   - Fix recommendations with code examples
4. Recommendations:
   - Immediate actions (critical fixes)
   - Short-term (1-2 weeks)
   - Medium-term (1-3 months)
   - Long-term (3-6 months)
   - Best practices to adopt/avoid
5. Action Plan: Prioritized task list with effort estimates, dependencies, implementation order, risk assessment
6. Metrics & Trends: Comparison with previous diagnostics, trend analysis, benchmarks, velocity metrics

PHASE 4: ADVANCED CODE ANALYSIS (V2 Enhanced)
- Architecture review (SSOT compliance, code organization, module boundaries, dependency graphs, circular dependencies, tight coupling)
- Pattern review (anti-patterns, best practice violations, error handling, code smells, duplicate code, complexity hotspots)
- Security review (OWASP Top 10, auth patterns, input validation, SAST, security anti-patterns, compliance checks)
- Performance review (query optimization, API performance, bundle size, bottlenecks, N+1 queries, caching opportunities)
- API analysis (contract validation, consistency checks, breaking changes, usage patterns)
- Generate architecture diagrams (dependency graphs, module relationships, code flow)

PHASE 5: ENHANCED REPORTING (V2)
Create comprehensive reports in multiple formats:
- Interactive HTML report (clickable navigation, expandable sections, searchable, filterable, visualizations)
- Markdown report (complete findings catalog, investigation results, recommendations, action plan)
- JSON summary (all scores, metrics, findings, fix history, trend data)
- Export options (PDF, Excel, CSV, JSON API)
- Include: Health score gauges, trend charts, issue distribution charts, dependency graphs, code heatmaps

PHASE 6: HISTORICAL ANALYSIS & TRENDS (V2)
- Load previous diagnostic results from time-series database
- Calculate trend metrics (improving/degrading areas, regression patterns, velocity metrics)
- Generate trend visualizations (health scores over time, issue heatmaps, fix velocity graphs)
- Benchmarking (industry standards, project goals, improvement velocity)
- Regression detection (fixed issues that reappeared, quality degradation patterns)

PHASE 7: PREDICTIVE ANALYSIS & RISK (V2)
- Predictive modeling (predict future issues, technical debt patterns, security vulnerabilities, performance degradation)
- Risk scoring (calculate risk scores per module, identify high-risk areas, assess business impact)
- Technical debt quantification (calculate in hours/days, estimate costs, identify hotspots, track accumulation rate)
- Dependency risk analysis (vulnerable chains, update impact, breaking change prediction)
- Generate predictive insights (files at risk, issue forecast, maintenance cost prediction, preventive actions)

PHASE 8: INTERACTIVE REMEDIATION (V2)
- Present fixable issues interactively (show context, before/after code, multiple options, explanations)
- Fix preview & approval (generate previews, request approval for risky fixes, batch approval, rollback capability)
- Apply fixes with validation (apply approved fixes, validate in real-time, run tests, check compilation)
- Progress tracking (track progress, show completion, display remaining, update status)
- Collaboration features (share findings, request reviews, track assignments, comments, notifications)

PHASE 9: TEAM WORKFLOW & COLLABORATION (V2)
- Issue assignment (assign to team members, track progress, set due dates, prioritize by assignee)
- Team metrics (track performance, measure fix velocity, identify bottlenecks, recognize improvements)
- Project management integration (create tickets, link to Jira/GitHub Issues, track in boards, auto-update status)
- Code review integration (pre-commit checks, PR quality analysis, review suggestions, automated feedback, quality gates)

PHASE 10: VALIDATION & VERIFICATION
- Verify all findings are real (not false positives)
- Confirm severity classifications are accurate
- Check for duplicate findings
- Ensure recommendations are actionable
- Validate action plan is feasible
- Cross-reference with known issues
- Verify fix effectiveness
- Set up continuous monitoring (quality gates, alerts, CI/CD integration, dashboard)

OUTPUT REQUIREMENTS:
- All diagnostic scores and metrics
- Complete list of findings with code examples, risk scores, fix categories
- Root cause analysis for each issue
- Impact assessment for each finding
- Automated fixes report (applied, pending, success rate)
- Detailed, actionable recommendations
- Prioritized action plan with timeline
- Risk assessment and predictive insights
- Historical trend analysis
- Interactive HTML report + Markdown + JSON summary
- Team workflow assignments and metrics

VALIDATION:
- Verify all findings are real (not false positives)
- Confirm severity classifications are accurate
- Check for duplicate findings
- Ensure recommendations are actionable
- Validate action plan is feasible
- Cross-reference with known issues
- Verify automated fixes don't break anything
- Validate historical data accuracy
- Confirm predictive insights are reasonable

Execute this complete workflow and provide the comprehensive diagnostic report with all findings, investigations, automated fixes, analysis, predictions, and recommendations.

