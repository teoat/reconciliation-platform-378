
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import lighthouse from 'lighthouse';
import { launch as chromeLauncherLaunch } from 'chrome-launcher';

const PERFORMANCE_RESULTS_DIR = path.join(new URL('.', import.meta.url).pathname, '../performance-results');
const LATEST_REPORT_PATH = path.join(PERFORMANCE_RESULTS_DIR, 'latest.json');
const BASELINE_REPORT_PATH = path.join(PERFORMANCE_RESULTS_DIR, 'baseline.json');

const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:3000';
const K6_API_URL = process.env.K6_API_URL || 'http://localhost:2000';

async function runK6Test(scriptPath, apiUrl) {
    console.log(`Running k6 test: ${scriptPath}`);
    try {
        // Ensure k6 is installed and in PATH
        execSync('k6 version', { stdio: 'ignore' });
    } catch (error) {
        console.warn('k6 not found in PATH. Attempting to install via brew...');
        try {
            execSync('brew install k6', { stdio: 'inherit' });
            console.log('k6 installed successfully via brew.');
        } catch (brewError) {
            console.error('Failed to install k6 via brew. Please install k6 manually (https://k6.io/docs/getting-started/installation/).');
            throw new Error('k6 not installed.');
        }
    }

    try {
        const k6Output = execSync(`K6_API_URL=${apiUrl} k6 run ${scriptPath} --out json`, { encoding: 'utf-8' });
        const k6Results = JSON.parse(k6Output);
        // Basic parsing for demonstration. Real parsing would be more detailed.
        const metrics = k6Results.metrics;
        return {
            http_req_duration_p95: metrics.http_req_duration ? metrics.http_req_duration.p(0.95) : null,
            http_req_failed_rate: metrics.http_req_failed ? metrics.http_req_failed.rate : null,
            // Add more k6 metrics as needed
        };
    } catch (error) {
        console.error(`Error running k6 test ${scriptPath}:`, error.message);
        return null;
    }
}

async function runLighthouseAudit(url) {
    console.log(`Running Lighthouse audit for: ${url}`);
    let chrome;
    try {
        chrome = await chromeLauncherLaunch({ chromeFlags: ['--headless'] });
        const options = { logLevel: 'info', output: 'json', port: chrome.port };
        const runnerResult = await lighthouse(url, options);

        const audits = runnerResult.lhr.audits;
        return {
            performanceScore: runnerResult.lhr.categories.performance.score * 100,
            fcp: audits['first-contentful-paint'].numericValue,
            lcp: audits['largest-contentful-paint'].numericValue,
            cls: audits['cumulative-layout-shift'].numericValue,
            tbt: audits['total-blocking-time'].numericValue,
            speedIndex: audits['speed-index'].numericValue,
        };
    } catch (error) {
        console.error(`Error running Lighthouse audit for ${url}:`, error.message);
        return null;
    } finally {
        if (chrome) {
            await chrome.kill();
        }
    }
}

async function generatePerformanceReport(isBaseline = false) {
    const timestamp = new Date().toISOString();
    let report = {
        timestamp,
        frontend: {},
        backend: {},
        summary: {},
        details: "Performance data generated by scripts/performance-test.mjs"
    };

    // 1. Run Lighthouse for Frontend Performance
    const lighthouseMetrics = await runLighthouseAudit(FRONTEND_URL);
    if (lighthouseMetrics) {
        report.frontend = lighthouseMetrics;
        report.summary.performanceScore = lighthouseMetrics.performanceScore;
    }

    // 2. Run k6 for Backend API Performance
    const k6LoadTestMetrics = await runK6Test(path.join(new URL('.', import.meta.url).pathname, '../load-test/k6-load-test.js'), K6_API_URL);
    const k6ReconciliationMetrics = await runK6Test(path.join(new URL('.', import.meta.url).pathname, '../load-test/k6-reconciliation.js'), K6_API_URL);

    if (k6LoadTestMetrics) {
        report.backend.loadTest = k6LoadTestMetrics;
        report.summary.apiDurationP95 = k6LoadTestMetrics.http_req_duration_p95;
    }
    if (k6ReconciliationMetrics) {
        report.backend.reconciliationTest = k6ReconciliationMetrics;
        // Add more summary metrics from reconciliation test if needed
    }

    if (!fs.existsSync(PERFORMANCE_RESULTS_DIR)) {
        fs.mkdirSync(PERFORMANCE_RESULTS_DIR, { recursive: true });
    }

    if (isBaseline) {
        fs.writeFileSync(BASELINE_REPORT_PATH, JSON.stringify(report, null, 2));
        console.log(`✅ Performance baseline generated: ${BASELINE_REPORT_PATH}`);
    } else {
        fs.writeFileSync(LATEST_REPORT_PATH, JSON.stringify(report, null, 2));
        console.log(`✅ Latest performance report generated: ${LATEST_REPORT_PATH}`);
    }
}

// Main execution
(async () => {
    const args = process.argv.slice(2);
    if (args.includes('--baseline')) {
        await generatePerformanceReport(true);
    } else {
        await generatePerformanceReport(false);
    }
})();
